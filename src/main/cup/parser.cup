package lyc.compiler;

import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Stack;
import SymbolTableGenerator.DataType;
import SymbolTableGenerator.SymbolEntry;
import SymbolTableGenerator.SymbolTableManager;
import Tercetos.Terceto;
import Tercetos.TercetoManager;

class Parser;

action code {:
    private boolean debug = true;
    private int SentenceIndex = 0;
    private int AssignmentIndex = 0;
    private int ExpressionIndex = 0;
    private int TermIndex = 0;
    private int FactorIndex = 0;
    private int InitRuleIndex = 0;
    private int InitBlockIndex = 0;
    private int CycleIndex = 0;
    private int ListIndex = 0;
    private int TypeIndex = 0;
    private int InitSentenceIndex = 0;
    private int BlockIndex = 0;
    private int thenBlockIndex = 0;
    private int elseBlockIndex = 0;
    private int nextBlockIndex = 0;
    private int CycleConditionIndex = 0;
    private int CycleBlockIndex = 0;
    private int TrueBlockIndex = 0;
    private int ElseBlockIndex = 0;
    private int OptionalIndex = 0;
    private int OperatorIndex = 0;
    private int conditionElementIndex = 0;
    private int conditionIndex = 0;
    private int SelectionIndex = 0;
    private int ReadIndex = 0;
    private int WriteIndex = 0;
    private int ConcatParamsIndex = 0;
    private int ConcatSentenceIndex = 0;
    private int NonTerminalIndex = 0;
    private int leftSideExpressionIndex = 0;
    private int branchIndex = 0;
    private int rightBranchIndex = 0;
    private int leftBranchIndex = 0;

    private String branchOperator = null;
    private String branchOppositeOperator = null;
    private String concatOperator = null;

    private ArrayList<Terceto> tercetos = TercetoManager.tercetos;
    private HashMap<String, SymbolEntry> symbolTable = SymbolTableManager.symbolTable;
    private ArrayList<String> VariableList = new ArrayList<String>();

    private DataType leftSideType = null;
    private DataType rightSideType = null;
    private DataType VariableType = null;
    private DataType FactorType = null;
    private DataType TermType = null;
    private DataType ExpressionType = null;

    private String ConcatFirstString = null;
    private String ConcatSecondString = null;
    private Integer ConcatIndex = null;

    private Stack<Integer> stack = new Stack<Integer>();
:};

// Terminals
terminal ASSIG;
terminal COLON;
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;
terminal GREATER;
terminal LESSER;
terminal GREATER_EQ;
terminal LESSER_EQ;
terminal EQUAL;
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal OPEN_CURLY_BRACKET;
terminal CLOSE_CURLY_BRACKET;
terminal INTEGER_CONSTANT;
terminal STRING_CONSTANT;
terminal FLOAT_CONSTANT;
terminal IDENTIFIER;
terminal COMA;
terminal CYCLE; // palabra reservada "ciclo"
terminal IF; // palabra reservada "if"
terminal ELSE; //palabra reservada "else"
terminal RESERVED_FLOAT; //palabra reservada "Float"
terminal RESERVED_INT; //palabra reservada "Int"
terminal RESERVED_STRING; //palabra reservada "String"
terminal RESERVED_CONCAT; //palabra reservada "ConcatenarConRecorte"
terminal INIT;
terminal WRITE;
terminal READ;
terminal AND;
terminal OR;
terminal NOT;


// Non Terminals
non terminal sentence;
non terminal assignment;
non terminal expression;
non terminal term;
non terminal factor;
non terminal initRule;
non terminal initBlock;
non terminal cycle;
non terminal list;
non terminal type;
non terminal initSentence;
non terminal block;
non terminal cycleCondition;
non terminal cycleBlock;
non terminal trueBlock;
non terminal elseBlock;
non terminal logicalConcat;
non terminal logicalOperator;
non terminal conditionElement;
non terminal condition;
non terminal selection;
non terminal read;
non terminal write;
non terminal concatParams;
non terminal concatSentence;
non terminal concatIndexParam;

non terminal program;

// Start Symbol Definition
start with program;

// INIT

program ::= block;
block ::= block sentence {::};
block ::= sentence {::};

// CONCATENAR CON RECORTE
/**

    private String ConcatFirstString = null;
    private String ConcatSecondString = null;
    private Integer ConcatIndex = null;
    **/
sentence ::= concatSentence {::};
concatSentence ::= RESERVED_CONCAT OPEN_BRACKET concatParams CLOSE_BRACKET {:
    System.out.println("concat sentence");
:};
concatParams ::= IDENTIFIER COMA IDENTIFIER COMA concatIndexParam {::};
concatParams ::= IDENTIFIER COMA STRING_CONSTANT COMA concatIndexParam {::};
concatParams ::= STRING_CONSTANT COMA IDENTIFIER COMA concatIndexParam {::};
concatParams ::= STRING_CONSTANT COMA STRING_CONSTANT COMA concatIndexParam {::};
concatIndexParam ::= IDENTIFIER:id {:
    if (debug) {
        System.out.println("Got concat index param identifier:" + id.toString());
    }

    if (SymbolTableManager.getType(id.toString()) != DataType.INTEGER_TYPE) {
        System.out.println("Error, se esperaba un entero como indice para recorte");
        System.exit(1);
    }
:};
concatIndexParam ::= INTEGER_CONSTANT:cte {:

:};

// IINIT

sentence ::= initRule {::};
initRule ::= INIT OPEN_CURLY_BRACKET initBlock CLOSE_CURLY_BRACKET {:System.out.println("INIT RULE");:};
initBlock ::= initBlock initSentence {::};
initBlock ::= initSentence {::};
initSentence ::= list COLON type {:
    if (debug) {
        System.out.println("Declaracion de variables");
    }

    for(String variable : VariableList) {
        SymbolTableManager.setDataType(variable, VariableType);
    }
    VariableList = new ArrayList<String>();
:};
list ::= list COMA IDENTIFIER:id {:
    VariableList.add(id.toString());
:};
list ::= IDENTIFIER:id {:
    VariableList.add(id.toString());
:};
type ::= RESERVED_INT:id {:
    VariableType = DataType.INTEGER_TYPE;
:};
type ::= RESERVED_FLOAT:id {:
    VariableType = DataType.FLOAT_TYPE;
:};
type ::= RESERVED_STRING {:
    VariableType = DataType.STRING_TYPE;
:};

// CYCLE

sentence ::= cycle {::};
cycle ::= CYCLE OPEN_BRACKET condition CLOSE_BRACKET OPEN_CURLY_BRACKET block CLOSE_CURLY_BRACKET {::};
//cycleCondition ::= OPEN_BRACKET condition CLOSE_BRACKET {::};
//cycleBlock ::= OPEN_CURLY_BRACKET block CLOSE_CURLY_BRACKET {::};

// IF

sentence ::= selection {::};
selection ::= IF OPEN_BRACKET condition CLOSE_BRACKET OPEN_CURLY_BRACKET block CLOSE_CURLY_BRACKET {:
        Integer tercetosSize = TercetoManager.getTercetosSize();
        nextBlockIndex = tercetosSize;
        branchIndex = stack.pop();
        TercetoManager.modificarSalto(branchIndex, "[" + nextBlockIndex + "]");
    :};
selection ::= IF OPEN_BRACKET condition CLOSE_BRACKET OPEN_CURLY_BRACKET block CLOSE_CURLY_BRACKET ELSE {:

        Integer inconditionalBranchIndex = TercetoManager.crearTerceto("BI", "_");

        Integer tercetosSize = TercetoManager.getTercetosSize();
        elseBlockIndex = tercetosSize;
        branchIndex = stack.pop();
        TercetoManager.modificarSalto(branchIndex, "[" + elseBlockIndex + "]");

        stack.push(inconditionalBranchIndex);
    :}
    OPEN_CURLY_BRACKET block CLOSE_CURLY_BRACKET {:
        Integer tercetosSize = TercetoManager.getTercetosSize();
        nextBlockIndex = tercetosSize;
        Integer inconditionalBranchIndex = stack.pop();

        TercetoManager.modificarSalto(inconditionalBranchIndex, "[" + nextBlockIndex + "]");
    :};
condition ::= NOT conditionElement {: TercetoManager.modificarOperador(branchIndex, branchOperator); stack.push(branchIndex); :};
condition ::= conditionElement logicalConcat {:
                 leftBranchIndex = branchIndex;
                 if(concatOperator == "OR"){
                    TercetoManager.modificarOperador(leftBranchIndex, branchOperator);
                 }
            :} conditionElement {:
                Integer tercetosSize = TercetoManager.getTercetosSize();
                thenBlockIndex = tercetosSize;
                rightBranchIndex = branchIndex;
                if(concatOperator == "OR") {
                    TercetoManager.modificarSalto(leftBranchIndex, "[" + thenBlockIndex + "]");
                    stack.push(rightBranchIndex);
                }
                else if(concatOperator == "AND") {
                    stack.push(leftBranchIndex);
                    stack.push(rightBranchIndex);
                }
            :};
condition ::= conditionElement {: stack.push(branchIndex); :};
conditionElement ::= expression {: leftSideExpressionIndex = ExpressionIndex; leftSideType = ExpressionType;:}
    logicalOperator expression {:
        rightSideType = ExpressionType;
        if(leftSideType != rightSideType) {
            System.out.println("Cannot compare " + leftSideType.getName() + " to " + rightSideType.getName());
            System.exit(1);
        }
        conditionElementIndex = TercetoManager.crearTerceto("CMP", "[" + leftSideExpressionIndex + "]", "[" + ExpressionIndex + "]");
        branchIndex = TercetoManager.crearTerceto(branchOppositeOperator, "_");
    :};

// Logic Operators

logicalConcat ::= AND {: concatOperator = "AND"; :};
logicalConcat ::= OR {: concatOperator = "OR"; :};
logicalOperator ::= EQUAL {: branchOperator = "BE"; branchOppositeOperator = "BNE"; :};
logicalOperator ::= GREATER {: branchOperator = "BGT"; branchOppositeOperator = "BLE"; :};
logicalOperator ::= GREATER_EQ {:branchOperator = "BGE"; branchOppositeOperator = "BLT"; :};
logicalOperator ::= LESSER {: branchOperator = "BLT"; branchOppositeOperator = "BGE"; :};
logicalOperator ::= LESSER_EQ {: branchOperator = "BLE"; branchOppositeOperator = "BGT"; :};


sentence ::= read {::};
read ::= READ OPEN_BRACKET IDENTIFIER CLOSE_BRACKET {::};
read ::= READ OPEN_BRACKET STRING_CONSTANT CLOSE_BRACKET {::};


sentence ::= write;
write ::= WRITE OPEN_BRACKET IDENTIFIER CLOSE_BRACKET {: System.out.print("WRITE"); :};
write ::= WRITE OPEN_BRACKET STRING_CONSTANT CLOSE_BRACKET {: System.out.print("WRITE"); :};


/* ARITMETIC EXPRESSION */
sentence ::= assignment {: System.out.println("End"); :};
assignment ::= IDENTIFIER:id ASSIG expression {:
    if(debug) {
        System.out.println("Assignment");
    }

    DataType idType = SymbolTableManager.getType(id.toString());
    if(idType != ExpressionType) {
        System.out.println("Cannot assign " + ExpressionType.getName() + " to " + idType.getName());
        System.exit(1);
    }

    AssignmentIndex = TercetoManager.crearTerceto("=", id.toString(), "[" + ExpressionIndex + "]");
:};
assignment ::= IDENTIFIER:id ASSIG STRING_CONSTANT:str {:
    if (debug) {
        System.out.println("Assignment");
    }

    AssignmentIndex = TercetoManager.crearTerceto("=", id.toString(), str.toString());

    DataType type = SymbolTableManager.getType(id.toString());
    if (type != DataType.STRING_TYPE) {
        System.out.println("Error: Asignacion de variable " + id.toString());
        System.exit(1);
    }

    SymbolTableManager.setValue(id.toString(), str.toString());
    SymbolTableManager.setLength(id.toString(), Integer.toString(str.toString().length()));

:};
assignment ::= IDENTIFIER ASSIG concatSentence {: System.out.println("Assignment de concatenar cadena"); :};
expression ::= expression PLUS term {:
    if (debug) {
        System.out.println("+");
    }

    if(ExpressionType == DataType.FLOAT_TYPE || TermType == DataType.FLOAT_TYPE) {
        ExpressionType = DataType.FLOAT_TYPE;
    }

    ExpressionIndex = TercetoManager.crearTerceto("+", "[" + ExpressionIndex + "]", "[" + TermIndex + "]");
:};
expression ::= expression SUB term {:
    if (debug) {
        System.out.println("-");
    }

    if(ExpressionType == DataType.FLOAT_TYPE || TermType == DataType.FLOAT_TYPE) {
        ExpressionType = DataType.FLOAT_TYPE;
    }

    ExpressionIndex = TercetoManager.crearTerceto("-", "[" + ExpressionIndex + "]", "[" + TermIndex + "]");
:};
expression ::= term {:
     if (debug) {
        System.out.println("Expression = Term");
     }

     ExpressionType = TermType;
     ExpressionIndex = TermIndex;
:};
term ::= term MULT factor {:
    if (debug) {
        System.out.println("*");
    }

    if(TermType == DataType.FLOAT_TYPE || FactorType == DataType.FLOAT_TYPE) {
        TermType = DataType.FLOAT_TYPE;
    }

    TermIndex = TercetoManager.crearTerceto("*", "[" + TermIndex + "]", "[" + FactorIndex + "]");
:};
term ::= term DIV factor {:
    if (debug) {
        System.out.println("/");
    }

    if(TermType == DataType.FLOAT_TYPE || FactorType == DataType.FLOAT_TYPE) {
        TermType = DataType.FLOAT_TYPE;
    }

    TermIndex = TercetoManager.crearTerceto("/", "[" + TermIndex + "]", "[" + FactorIndex + "]");
:};
term ::= factor {:
    if (debug) {
        System.out.println("Term = factor");
    }

    TermIndex = FactorIndex;
    TermType = FactorType;
:};
factor ::= IDENTIFIER:identifier  {:
                                    if (debug) {
                                        System.out.println("Id: " + identifier);
                                    }
                                    FactorIndex = TercetoManager.crearTerceto(identifier.toString());
                                    FactorType = SymbolTableManager.getType(identifier.toString());
                                :};
factor ::= INTEGER_CONSTANT:constant {:
                                        if (debug) {
                                            System.out.println("Constant: " + constant );
                                        }

                                        FactorIndex = TercetoManager.crearTerceto(constant.toString());
                                        FactorType = DataType.INTEGER_TYPE;
                                :};
factor ::= FLOAT_CONSTANT:constant {:
                                        if (debug) {
                                            System.out.println("Constant: " + constant );
                                        }
                                        else {
                                            FactorIndex = TercetoManager.crearTerceto(constant.toString());
                                            FactorType = DataType.FLOAT_TYPE;
                                        }
                                :};
factor ::= OPEN_BRACKET expression CLOSE_BRACKET {: System.out.println("Factor = (Expression)"); :};

/*  */